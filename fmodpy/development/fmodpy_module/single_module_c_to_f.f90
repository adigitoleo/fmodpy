! This automatically generated Fortran wrapper file allows codes
! written in Fortran to be called directly from C and translates all
! C-style arguments into expected Fortran-style arguments (with
! assumed size, local type declarations, etc.).

MODULE C_SIMPLE_TEST
  USE ISO_FORTRAN_ENV, ONLY: REAL64, INT64
  USE SIMPLE_TEST
  ! All variables should be defined, using no implicits.
  IMPLICIT NONE

CONTAINS
  
  SUBROUTINE C_ADD(ADD_A, ADD_B, ADD_C) BIND(C)
    IMPLICIT NONE
    REAL(KIND=REAL64), INTENT(IN) :: ADD_A
    REAL(KIND=REAL64), INTENT(IN) :: ADD_B
    REAL(KIND=REAL64), INTENT(OUT) :: ADD_C
  
    CALL ADD(ADD_A, ADD_B, ADD_C)
  END SUBROUTINE c_ADD
  
  
  SUBROUTINE C_TAUTOLOGY(YES) BIND(C)
    IMPLICIT NONE
    LOGICAL :: YES
  
    YES = TAUTOLOGY()
  END SUBROUTINE c_TAUTOLOGY
  
  
  SUBROUTINE C_FALSEHOOD(FALSEHOOD_RESULT) BIND(C)
    IMPLICIT NONE
    LOGICAL :: FALSEHOOD_RESULT
  
    FALSEHOOD_RESULT = FALSEHOOD()
  END SUBROUTINE c_FALSEHOOD
  
  
  SUBROUTINE C_SUBTRACT(SUB_A, SUB_B, SUB_C) BIND(C)
    IMPLICIT NONE
    REAL, INTENT(IN) :: SUB_A
    REAL, INTENT(IN) :: SUB_B
    REAL :: SUB_C
  
    SUB_C = SUBTRACT(SUB_A, SUB_B)
  END SUBROUTINE c_SUBTRACT
  
  
  SUBROUTINE C_MULTIPLY(MULT_A, MULT_B, MULTIPLY_RESULT) BIND(C)
    IMPLICIT NONE
    REAL, INTENT(IN) :: MULT_A
    INTEGER(KIND=INT64), INTENT(IN) :: MULT_B
    REAL :: MULTIPLY_RESULT
  
    MULTIPLY_RESULT = MULTIPLY(MULT_A, MULT_B)
  END SUBROUTINE c_MULTIPLY
  
END MODULE c_SIMPLE_TEST
